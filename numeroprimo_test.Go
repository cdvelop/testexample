package testexample

import (
    "fmt"
    "math"
)

// Descripci√≥n:
// Un n√∫mero primo es aquel mayor que 1 que solo tiene dos divisores: 1 y √©l mismo.
// Es decir, no puede dividirse exactamente (sin residuo) por ning√∫n otro n√∫mero.
//
// Ejemplos de n√∫meros primos: 2, 3, 5, 7, 11, 13...
// Ejemplos de no primos: 1 (no cuenta como primo), 4 (2*2), 6 (2*3), 8 (2*4).
//
// IsPrime retorna true si n es un n√∫mero primo.
// Ejemplo: IsPrime(7) == true
// Ejemplo: IsPrime(10) == false
func IsPrime(n int) bool {
    // 1. Manejo de casos triviales y no primos por definici√≥n.
    if n <= 1 {
        // Los n√∫meros menores o iguales a 1 no son primos.
        return false
    }

    // 2. Manejo del 2 (el √∫nico n√∫mero primo par).
    if n == 2 {
        return true
    }

    // 3. Excluir el resto de los n√∫meros pares.
    if n%2 == 0 {
        // Cualquier n√∫mero par mayor que 2 no es primo.
        return false
    }

    // 4. Bucle de optimizaci√≥n: Solo necesitamos verificar divisores impares hasta la ra√≠z cuadrada de n.
    // Si un n√∫mero tiene un divisor mayor que su ra√≠z cuadrada, autom√°ticamente tiene uno menor.
    // Usamos int(math.Sqrt(float64(n))) para obtener la ra√≠z cuadrada.
    limit := int(math.Sqrt(float64(n)))
    for i := 3; i <= limit; i += 2 {
        if n%i == 0 {
            // Si encontramos alg√∫n divisor, el n√∫mero no es primo.
            return false
        }
    }

    // 5. Si no se encontr√≥ ning√∫n divisor, el n√∫mero es primo.
    return true
}

üß™ Pruebas de Validaci√≥n (Funci√≥n main)
Para asegurarte de que tu funci√≥n trabaja correctamente, aqu√≠ tienes la funci√≥n main para probar varios casos, incluidos los ejemplos que se esperan.

Go

func main() {
    fmt.Println("--- ‚úÖ Caso 012 ‚Äì N√∫mero Primo (Pruebas) ---")

    // Pruebas de N√∫meros Primos
    fmt.Println("\n--- Primos (Expected: true) ---")
    primos := []int{2, 3, 5, 7, 13, 17, 97, 101}
    for _, num := range primos {
        // En un formato claro: IsPrime(7) -> true
        fmt.Printf("IsPrime(%d) -> %t\n", num, IsPrime(num))
    }

    // Pruebas de N√∫meros No Primos
    fmt.Println("\n--- No Primos (Expected: false) ---")
    noPrimos := []int{1, 4, 6, 9, 10, 15, 100, 10000}
    for _, num := range noPrimos {
        // En un formato claro: IsPrime(10) -> false
        fmt.Printf("IsPrime(%d) -> %t\n", num, IsPrime(num))
    }

    // Caso L√≠mite
    fmt.Println("\n--- Caso L√≠mite (Expected: false) ---")
    fmt.Printf("IsPrime(1) -> %t\n", 1, IsPrime(1)) // 1 no es primo por definici√≥n

    // Caso de No Primo grande que requiere la optimizaci√≥n de la ra√≠z cuadrada
    fmt.Println("\n--- Prueba de Optimizaci√≥n (Expected: false) ---")
    numGrande := 121 // 11 * 11
    fmt.Printf("IsPrime(%d) -> %t (Ra√≠z cuadrada de 121 es 11)\n", numGrande, IsPrime(numGrande)) 
}